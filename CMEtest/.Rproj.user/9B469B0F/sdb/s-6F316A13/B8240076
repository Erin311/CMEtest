{
    "contents" : "\n##' Covariance specification object Constructor.\n##' .. content for \\description{} (no empty lines) ..\n##' This function allows specification of a covariance objects.\n##' .. content for \\details{} ..\n##' \n##' @title General Interface for covariance matrix specification\n##' @param smooth character specifying to smoothing method.\n##' @param smoothCtrl list containing smoothing parameters\n##' @param estim  character specifying which estimation methods ('mle', 'mcd', 'mve,...)\n##' @param estimCtrl list containing estimation parameters\n##' @param shrink character specifying which covariance shrinkage methode to choose\n##' @param shrinkCtrl list containing shrinkage parameters\n##' @param filter character specifying which filtering method to choose\n##' @param filterCtrl list containing filtering parameters\n##' @return CMEspec: S3 object containing complete specification\n##' @author Mohamed Ishmael Diwan Belghazi\n##' @import robust\n##' @export\nCovSpec <- function(smooth = NULL,\n                    smoothCtrl = list(),\n                    estim = \"auto\",\n                    estimCtrl = list(),\n                    shrink = NULL,\n                    shrinkCtrl = list(),\n                    filter = NULL,\n                    filterCtrl = list()) {\n\n\n    ## Note this is just a quick ugly hack. This will be rewritten to use the building blacks approach\n\n    ## defining dictionary for  methods to  function around different packages\n    ## Here will be made all the external functions book keeping\n\n\n\n    ## Smoothing methods\n    smoothList <- NULL\n    smoothDic <- NULL\n    names(smoothDic) <- smoothList\n\n    ## Estimation methods\n    robEstList <- c(\"auto\",\n                    \"mcd\",\n                    \"weighted\",\n                    \"donostah\",\n                    \"pairwiseQC\",\n                    \"pairwiseGK\")\n    robEstDic <- rep('covRob', length(robEstList))\n    names(robEstDic) <- robEstList\n\n    clasEstList <- c(\"mle\")\n    clasEstDic <- rep('covClassic', length(clasEstList))\n    names(clasEstDic) <- clasEstList\n\n    estimDic <- c(robEstDic, clasEstDic)\n\n    ## Shrinkage  methods\n    shrinkList <- NULL\n    shrinkDic <- NULL\n    names(shrinkDic) <- NULL\n\n    ## filtering methods\n    filterList <- NULL\n    filterDic <- NULL\n    names(filterDic) <- filterList\n\n    ## Wrapping all the dictionary in a large \"mapping\" dictionary\n    mapDic <- list(smooth = smoothDic,\n                   estim = estimDic,\n                   shrink = shrinkDic,\n                   filter = filterDic)\n\n    ## Recording call. match.call() is not enough for printing default argument.\n    CALL <- mget(names(formals()),sys.frame(sys.nframe()))\n\n    if(!(CALL$estim %in% names(estimDic)))\n        stop(\"Unrecognized Estimation method\")\n\n    argVec <- sapply(CALL, deparse)\n    specCat <-names(argVec[!(grepl('Ctrl', names(argVec)))])\n    ## The following function create a list containing the called function\n    ## and the call. A sort of function dispatcher. Formatting of the calls will\n    ## be handled here. Of course, the call will depend on the receiving funcion\n    ## the function returns a list containing fun, a character representing the function\n    ## and call\n    MakeAtr <- function(X) {\n\n        switch(X,\n\n               smooth = {\n                   fun = NULL\n                   funCall = NULL\n                   computeMet <- NULL\n               },\n\n               estim = {\n\n                   ## Getting function to be used from mapping dictionary\n                   ## Getting relevant dictionary\n                   estDic <- mapDic[[X]]\n                   ## Getting function to be called\n                   fun <- as.character(estDic[names(estDic) == estim])\n                   ## Modifying function call to fit covrob and covClassic\n                   if(fun == 'covRob' || fun == 'covClassic'){\n                       funCall <- CALL$estimCtrl\n                       funCall[['estim']] <- estim\n                       computeMet <- estim\n\n                   }\n               },\n               shrink = {\n                   fun <- NULL\n                   funCall <- NULL\n                   computeMet <- NULL\n               },\n\n               filter ={\n                   fun <- NULL\n                   funCall <- NULL\n                   computeMet <- NULL\n               }\n               )\n\n        return(list(fun = fun, funCall = funCall, computeMet = computeMet))\n    }\n\n\n    spec <- sapply(specCat, MakeAtr, simplify = FALSE)\n    spec[['CALL']] <- CALL\n    spec[['categories']] <- specCat\n    class(spec) <-'CMEspec'\n    return(spec)\n\n}\n\n\n##' .. content for \\description{} (no empty lines) ..\n##'\n##' .. content for \\details{} ..\n##' @title summary of specification object\n##' @param object\n##' @return nothing\n##' @author Mohamed Ishmael Diwan Belghazi\n##' @export\nsummary.CMEspec <- function(object, ...) {\n    cat('/----------------------------------\\\\\\n')\n    cat('|Matrix Covariance Estimators demo |\\n')\n    cat('\\\\----------------------------------/\\n\\n\\n')\n    cat(\"\\t Specification summary\\n\\n\")\n    cat(sprintf('\\tSmoothing: %s\\n', object$smooth$computeMet))\n    cat(sprintf('\\tEstimation: %s\\n', object$estim$computeMet))\n    cat(sprintf('\\tShrinking: %s\\n', object$shrink$computeMet))\n    cat(sprintf('\\tFiltering: %s\\n', object$smooth$computeMet))\n    cat(\"\\n-----------------------------------\\n\")\n\n\n}\n\n##' .. content for \\description{} (no empty lines) ..\n##'\n##' .. content for \\details{} ..\n##' @title Estimate specObj\n##' @param Obj\n##' @param data\n##' @return CMEest\n##' @author Mohamed Ishmael Diwan Belghazi\n##' @export\nEstimate <- function(Obj, data) UseMethod('Estimate')\n##' @export\nEstimate.default <- function(Obj, data) warning(\"Unknown Class\")\n##' @export\nEstimate.CMEspec <- function(specObj, data) {\n\n    ## Getting back call from specification object\n\n    if(dim(data)[1] <= dim(data)[2])\n        stop(\"n <= p. Witchcraft is not allowed... for now\")\n\n    estimFUN <- specObj$estim$fun\n    estimArgs <- specObj$estim$funCall\n    estimArgs[['data']] <- data\n    estimObj <- do.call(estimFUN, estimArgs)\n\n\n    ## Getting Estimated correlation or covariance matrix\n    class(estimObj) <- c('CMEest', class(estimObj))\n\n    return(estimObj)\n\n\n}\n\n#########################################\n## Defining setter and getters for CME ##\n#########################################\n\n## Note to be mistaken with the S4 getCov from rrcov.\n##' .. content for \\description{} (no empty lines) ..\n##'\n##' .. content for \\details{} ..\n##' @title Extact covariance from estimation object\n##' @param Obj\n##' @return covariance\n##' @author Mohamed Ishmael Diwan Belghazi\n##' @export\nGetCov <- function(Obj) UseMethod(\"GetCov\")\n##' @export\nGetCov.default <- function(Obj) warning(\"Unknown class\")\n##' @export\nGetCov.CMEspec <- function(specObj) cat(\"Estimate specfication first\")\n##' @export\nGetCov.CMEest <- function(estObj) {\n\n    # Checking if the object contains covariance or correlation. Note that, contrary to the 'robust' package CME passe the data to the object. So it should be possible to return the covariance directly without reestimating the whole object. I am still pondering if it make sense to this here\n    if(estObj$corr) warning(\"Returning correlation. Restimate with corr = FALSE\")\n\n    return(estObj$cov)\n}\n\n\n\n##' .. content for \\description{} (no empty lines) ..\n##'\n##' .. content for \\details{} ..\n##' @title Extracts Corrlation from estimation object\n##' @param Obj\n##' @return Returns Correlation\n##' @author Mohamed Ishmael Diwan Belghazi\n##' @export\nGetCorr <- function(Obj) UseMethod(\"GetCorr\")\n##' @export\nGetCorr.default <- function(Obj) warning(\"Unknown class\")\n##' @export\nGetCorr.CMEspec <- function(specObj) cat(\"Estimate specfication first\")\n##' @export\nGetCorr.CMEest <- function(estObj) {\n\n    if(estObj$corr){\n        corr <- estObj$cov\n    } else {\n        corr <- cov2cor(estObj$cov)\n    }\n\n    return(corr)\n\n}\n\n##' .. content for \\description{} (no empty lines) ..\n##' \n##' .. content for \\details{} ..\n##' @title Extract location from Estimation Object\n##' @param Obj\n##' @return Location\n##' @author Mohamed Ishmael Diwan Belghazi\n##' @export\nGetLoc <- function(Obj) UseMethod(\"GetLoc\")\n##' @export\nGetLoc.default <- function(Obj) warning(\"Unknown class\")\n##' @export\nGetLoc.CMEspec <- function(specObj) cat(\"Estimate specfication first\")\n##' @export\nGetLoc.CMEest <- function(estObj) {\n\n  return(estObj$center)\n\n}\n##########################################################\n## Defining Make moment function for PortfolioAnalytics ##\n##########################################################\n\n##' .. content for \\description{} (no empty lines) ..\n##'\n##' .. content for \\details{} ..\n##' @title Generates moment function from spec or estimation object \n##' @param Obj\n##' @return moment function for portfolioanalytics.\n##' @author Mohamed Ishmael Diwan Belghazi\n##' @import PerformanceAnalytics\n##' @export \nMakeMomentFUN <- function(Obj) UseMethod('MakeMomentFUN')\n##' @export\nMakeMomentFUN.default <- function(Obj) cat(\"Class unknown\")\n\n##' @export\nMakeMomentFUN.CMEspec <- function(specObj) {\n\n    momFUN <- function(R, portfolio, momentargs = list(), ...) {\n\n        ## Estimating Robust Location and scatter\n        if(is.null(momentargs$mu) || is.null(momentargs$sigma))\n            CMEmom <- Estimate(specObj, R)\n\n        if(is.null(momentargs$mu))\n            momentargs$mu <- matrix(GetLoc(CMEmom), ncol = 1)\n\n        if(is.null(momentargs$sigma))\n            momentargs$sigma <- GetCov(CMEmom)\n\n        if(is.null(momentargs$m3))\n            momentargs$m3 <- PerformanceAnalytics:::M3.MM(R)\n\n        if(is.null(momentargs$m4))\n            momentargs$m4 <- PerformanceAnalytics:::M4.MM(R)\n\n        return(momentargs)\n    }\n\n\n    return(momFUN)\n}\n\n##' @export\nMakeMomentFUN.CMEest <- function(estObj) {\n\n    momFUN <- function(R, portfolio, momentargs = list(), ...) {\n\n        ## Estimating Robust Location and scatter\n\n        if(is.null(momentargs$mu))\n            momentargs$mu <- matrix(GetLoc(estObj), ncol = 1)\n\n        if(is.null(momentargs$sigma))\n            momentargs$sigma <-  GetCov(estObj)\n\n        if(is.null(momentargs$m3))\n            momentargs$m3 <- PerformanceAnalytics:::M3.MM(R)\n\n        if(is.null(momentargs$m4))\n            momentargs$m4 <- PerformanceAnalytics:::M4.MM(R)\n\n        return(momentargs)\n    }\n\n\n    return(momFUN)\n}\n",
    "created" : 1395611667804.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2281792117",
    "id" : "B8240076",
    "lastKnownWriteTime" : 1395615007,
    "path" : "~/Dropbox/gsoc2014/GSOC2014/testpkgfinal/CMEtest/R/CMEtest.R",
    "project_path" : "R/CMEtest.R",
    "properties" : {
    },
    "source_on_save" : true,
    "type" : "r_source"
}